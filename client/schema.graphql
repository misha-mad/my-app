schema {
	query: query_root
	mutation: mutation_root
	subscription: subscription_root
}

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(
	"""
	measured in seconds
	"""
	ttl: Int! = 60

	"""
	refresh the cache entry
	"""
	refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
	_eq: Boolean
	_gt: Boolean
	_gte: Boolean
	_in: [Boolean!]
	_is_null: Boolean
	_lt: Boolean
	_lte: Boolean
	_neq: Boolean
	_nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
	_eq: String
	_gt: String
	_gte: String

	"""
	does the column match the given case-insensitive pattern
	"""
	_ilike: String
	_in: [String!]

	"""
	does the column match the given POSIX regular expression, case insensitive
	"""
	_iregex: String
	_is_null: Boolean

	"""
	does the column match the given pattern
	"""
	_like: String
	_lt: String
	_lte: String
	_neq: String

	"""
	does the column NOT match the given case-insensitive pattern
	"""
	_nilike: String
	_nin: [String!]

	"""
	does the column NOT match the given POSIX regular expression, case insensitive
	"""
	_niregex: String

	"""
	does the column NOT match the given pattern
	"""
	_nlike: String

	"""
	does the column NOT match the given POSIX regular expression, case sensitive
	"""
	_nregex: String

	"""
	does the column NOT match the given SQL regular expression
	"""
	_nsimilar: String

	"""
	does the column match the given POSIX regular expression, case sensitive
	"""
	_regex: String

	"""
	does the column match the given SQL regular expression
	"""
	_similar: String
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
	"""
	ascending ordering of the cursor
	"""
	ASC

	"""
	descending ordering of the cursor
	"""
	DESC
}

"""
mutation root
"""
type mutation_root {
	"""
	delete data from the table: "todo"
	"""
	delete_todo(
		"""
		filter the rows which have to be deleted
		"""
		where: todo_bool_exp!
	): todo_mutation_response

	"""
	delete single row from the table: "todo"
	"""
	delete_todo_by_pk(id: uuid!): todo

	"""
	insert data into the table: "todo"
	"""
	insert_todo(
		"""
		the rows to be inserted
		"""
		objects: [todo_insert_input!]!

		"""
		upsert condition
		"""
		on_conflict: todo_on_conflict
	): todo_mutation_response

	"""
	insert a single row into the table: "todo"
	"""
	insert_todo_one(
		"""
		the row to be inserted
		"""
		object: todo_insert_input!

		"""
		upsert condition
		"""
		on_conflict: todo_on_conflict
	): todo

	"""
	update data of the table: "todo"
	"""
	update_todo(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: todo_set_input

		"""
		filter the rows which have to be updated
		"""
		where: todo_bool_exp!
	): todo_mutation_response

	"""
	update single row of the table: "todo"
	"""
	update_todo_by_pk(
		"""
		sets the columns of the filtered rows to the given values
		"""
		_set: todo_set_input
		pk_columns: todo_pk_columns_input!
	): todo

	"""
	update multiples rows of table: "todo"
	"""
	update_todo_many(
		"""
		updates to execute, in order
		"""
		updates: [todo_updates!]!
	): [todo_mutation_response]
}

"""
column ordering options
"""
enum order_by {
	"""
	in ascending order, nulls last
	"""
	asc

	"""
	in ascending order, nulls first
	"""
	asc_nulls_first

	"""
	in ascending order, nulls last
	"""
	asc_nulls_last

	"""
	in descending order, nulls first
	"""
	desc

	"""
	in descending order, nulls first
	"""
	desc_nulls_first

	"""
	in descending order, nulls last
	"""
	desc_nulls_last
}

type query_root {
	"""
	fetch data from the table: "todo"
	"""
	todo(
		"""
		distinct select on columns
		"""
		distinct_on: [todo_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [todo_order_by!]

		"""
		filter the rows returned
		"""
		where: todo_bool_exp
	): [todo!]!

	"""
	fetch aggregated fields from the table: "todo"
	"""
	todo_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [todo_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [todo_order_by!]

		"""
		filter the rows returned
		"""
		where: todo_bool_exp
	): todo_aggregate!

	"""
	fetch data from the table: "todo" using primary key columns
	"""
	todo_by_pk(id: uuid!): todo
}

type subscription_root {
	"""
	fetch data from the table: "todo"
	"""
	todo(
		"""
		distinct select on columns
		"""
		distinct_on: [todo_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [todo_order_by!]

		"""
		filter the rows returned
		"""
		where: todo_bool_exp
	): [todo!]!

	"""
	fetch aggregated fields from the table: "todo"
	"""
	todo_aggregate(
		"""
		distinct select on columns
		"""
		distinct_on: [todo_select_column!]

		"""
		limit the number of rows returned
		"""
		limit: Int

		"""
		skip the first n rows. Use only with order_by
		"""
		offset: Int

		"""
		sort the rows by one or more columns
		"""
		order_by: [todo_order_by!]

		"""
		filter the rows returned
		"""
		where: todo_bool_exp
	): todo_aggregate!

	"""
	fetch data from the table: "todo" using primary key columns
	"""
	todo_by_pk(id: uuid!): todo

	"""
	fetch data from the table in a streaming manner: "todo"
	"""
	todo_stream(
		"""
		maximum number of rows returned in a single batch
		"""
		batch_size: Int!

		"""
		cursor to stream the results returned by the query
		"""
		cursor: [todo_stream_cursor_input]!

		"""
		filter the rows returned
		"""
		where: todo_bool_exp
	): [todo!]!
}

"""
A table that contains all the things that need to be done or have already been done
"""
type todo {
	id: uuid!
	isDone: Boolean!
	name: String!
}

"""
aggregated selection of "todo"
"""
type todo_aggregate {
	aggregate: todo_aggregate_fields
	nodes: [todo!]!
}

"""
aggregate fields of "todo"
"""
type todo_aggregate_fields {
	count(columns: [todo_select_column!], distinct: Boolean): Int!
	max: todo_max_fields
	min: todo_min_fields
}

"""
Boolean expression to filter rows from the table "todo". All fields are combined with a logical 'AND'.
"""
input todo_bool_exp {
	_and: [todo_bool_exp!]
	_not: todo_bool_exp
	_or: [todo_bool_exp!]
	id: uuid_comparison_exp
	isDone: Boolean_comparison_exp
	name: String_comparison_exp
}

"""
unique or primary key constraints on table "todo"
"""
enum todo_constraint {
	"""
	unique or primary key constraint on columns "id"
	"""
	todo_pkey
}

"""
input type for inserting data into table "todo"
"""
input todo_insert_input {
	id: uuid
	isDone: Boolean
	name: String
}

"""
aggregate max on columns
"""
type todo_max_fields {
	id: uuid
	name: String
}

"""
aggregate min on columns
"""
type todo_min_fields {
	id: uuid
	name: String
}

"""
response of any mutation on the table "todo"
"""
type todo_mutation_response {
	"""
	number of rows affected by the mutation
	"""
	affected_rows: Int!

	"""
	data from the rows affected by the mutation
	"""
	returning: [todo!]!
}

"""
on_conflict condition type for table "todo"
"""
input todo_on_conflict {
	constraint: todo_constraint!
	update_columns: [todo_update_column!]! = []
	where: todo_bool_exp
}

"""
Ordering options when selecting data from "todo".
"""
input todo_order_by {
	id: order_by
	isDone: order_by
	name: order_by
}

"""
primary key columns input for table: todo
"""
input todo_pk_columns_input {
	id: uuid!
}

"""
select columns of table "todo"
"""
enum todo_select_column {
	"""
	column name
	"""
	id

	"""
	column name
	"""
	isDone

	"""
	column name
	"""
	name
}

"""
input type for updating data in table "todo"
"""
input todo_set_input {
	id: uuid
	isDone: Boolean
	name: String
}

"""
Streaming cursor of the table "todo"
"""
input todo_stream_cursor_input {
	"""
	Stream column input with initial value
	"""
	initial_value: todo_stream_cursor_value_input!

	"""
	cursor ordering
	"""
	ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input todo_stream_cursor_value_input {
	id: uuid
	isDone: Boolean
	name: String
}

"""
update columns of table "todo"
"""
enum todo_update_column {
	"""
	column name
	"""
	id

	"""
	column name
	"""
	isDone

	"""
	column name
	"""
	name
}

input todo_updates {
	"""
	sets the columns of the filtered rows to the given values
	"""
	_set: todo_set_input

	"""
	filter the rows which have to be updated
	"""
	where: todo_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
	_eq: uuid
	_gt: uuid
	_gte: uuid
	_in: [uuid!]
	_is_null: Boolean
	_lt: uuid
	_lte: uuid
	_neq: uuid
	_nin: [uuid!]
}
